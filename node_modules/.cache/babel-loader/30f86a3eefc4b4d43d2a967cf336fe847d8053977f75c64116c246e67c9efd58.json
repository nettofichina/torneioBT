{"ast":null,"code":"// src/utils/torneioUtils.js\nexport const classificarDuplas = grupos => {\n  let classificados = [];\n  grupos.forEach(grupo => {\n    // Ordena duplas do grupo com base nos critérios de desempate\n    const duplasClassificadas = classificarDuplasPorDesempate(grupo.duplas, grupo.jogos);\n\n    // Adiciona os 2 melhores de cada grupo à lista de classificados\n    classificados.push(duplasClassificadas[0], duplasClassificadas[1]);\n  });\n  console.log(\"Duplas classificadas para a fase eliminatória:\", classificados);\n  return classificados;\n};\nexport const criarJogosParaGrupo = (duplas, grupoId) => {\n  const jogos = [];\n  for (let i = 0; i < duplas.length; i++) {\n    for (let j = i + 1; j < duplas.length; j++) {\n      jogos.push({\n        dupla1: duplas[i],\n        dupla2: duplas[j],\n        placar: '',\n        submetido: false,\n        grupoId\n      });\n    }\n  }\n  return jogos;\n};\nexport const dividirGrupos = duplas => {\n  let numGrupos = Math.ceil(duplas.length / 3); // 3 é o número mínimo de duplas por grupo\n\n  if (duplas.length <= 5) numGrupos = 1; // Grupo único para até 5 duplas\n  else if (duplas.length <= 8) numGrupos = 2;else if (duplas.length <= 11) numGrupos = 3;else if (duplas.length <= 14) numGrupos = 4;else if (duplas.length <= 17) numGrupos = 5;else if (duplas.length <= 20) numGrupos = 6;\n  const grupos = Array(numGrupos).fill().map((_, i) => ({\n    id: i,\n    duplas: duplas.slice(i * Math.ceil(duplas.length / numGrupos), (i + 1) * Math.ceil(duplas.length / numGrupos))\n  }));\n  return grupos;\n};\nexport const classificarDuplasPorDesempate = (duplas, jogos) => {\n  const resultados = duplas.reduce((acc, dupla) => {\n    acc[dupla.join('')] = {\n      dupla,\n      pontos: 0,\n      saldoGames: 0\n    };\n    return acc;\n  }, {});\n  jogos.forEach(jogo => {\n    if (jogo.placar) {\n      const [games1, games2] = jogo.placar.split('-').map(Number);\n      const chave1 = jogo.dupla1.join('');\n      const chave2 = jogo.dupla2.join('');\n      if (games1 > games2) {\n        resultados[chave1].pontos += 5;\n        resultados[chave2].pontos += 2; // Pode ajustar essa pontuação se necessário\n      } else {\n        resultados[chave2].pontos += 5;\n        resultados[chave1].pontos += 2;\n      }\n\n      // Adiciona saldo de games para critério de desempate\n      resultados[chave1].saldoGames += games1 - games2;\n      resultados[chave2].saldoGames += games2 - games1;\n    }\n  });\n\n  // Ordena primeiro por pontos, depois por saldo de games\n  return Object.values(resultados).sort((a, b) => b.pontos - a.pontos || b.saldoGames - a.saldoGames).map(r => r.dupla);\n};\nexport const iniciarFaseEliminatoria = classificados => {\n  let jogosEliminatoria = [];\n  let rodada = 1;\n\n  // Classificação das duplas\n  const classificadosOrdenados = classificados;\n\n  // Determina o número de rodadas necessárias\n  let rodadasTotal = Math.ceil(Math.log2(classificadosOrdenados.length));\n\n  // Se for um número de duplas que não é potência de 2, ajustamos para incluir BYEs\n  let proximoMultiplo = Math.pow(2, rodadasTotal);\n\n  // Adiciona BYEs se necessário\n  while (classificadosOrdenados.length < proximoMultiplo) {\n    classificadosOrdenados.push(['BYE', '']);\n  }\n\n  // Aqui, para casos específicos como 9 duplas, ajustamos manualmente:\n  if (classificados.length === 9) {\n    // Para 9 duplas, 2 avançam BYE, 4 para quartas\n    jogosEliminatoria = [...classificadosOrdenados.slice(2, 6).reduce((acc, dupla, index) => {\n      if (index % 2 === 0) {\n        acc.push({\n          dupla1: dupla,\n          dupla2: classificadosOrdenados[2 + index + 1],\n          placar: '',\n          submetido: false,\n          fase: 'Quartas de Final',\n          rodada: 1\n        });\n      }\n      return acc;\n    }, []), {\n      dupla1: classificadosOrdenados[0],\n      dupla2: ['BYE', ''],\n      placar: '',\n      submetido: false,\n      fase: 'Semifinal',\n      rodada: 2\n    }, {\n      dupla1: classificadosOrdenados[1],\n      dupla2: ['BYE', ''],\n      placar: '',\n      submetido: false,\n      fase: 'Semifinal',\n      rodada: 2\n    }];\n    return jogosEliminatoria;\n  }\n\n  // Lógica para outros casos (número de duplas != 9)\n  for (let i = 0; i < classificadosOrdenados.length; i += 2) {\n    let faseNome = rodadasTotal === 1 ? 'Final' : rodadasTotal === 2 ? 'Semifinal' : rodadasTotal === 3 ? 'Quartas de Final' : `Rodada ${rodada}`;\n    jogosEliminatoria.push({\n      dupla1: classificadosOrdenados[i],\n      dupla2: classificadosOrdenados[i + 1] || ['BYE', ''],\n      placar: '',\n      submetido: false,\n      fase: faseNome,\n      rodada: rodada\n    });\n  }\n  return jogosEliminatoria;\n};\nexport const avancarRodadaEliminatoria = jogosRodadaAtual => {\n  let vencedores = jogosRodadaAtual.map(jogo => {\n    const [score1, score2] = jogo.placar.split('-').map(Number);\n    if (jogo.dupla2[0] === 'BYE') return jogo.dupla1;\n    if (isNaN(score1) || isNaN(score2)) return jogo.dupla1; // Placeholder caso não tenha placar\n    return score1 > score2 ? jogo.dupla1 : jogo.dupla2;\n  });\n  let rodadasTotal = Math.ceil(Math.log2(vencedores.length));\n  let novaFaseNome = ['Final', 'Semifinal', 'Quartas de Final'][rodadasTotal - 1] || `Rodada ${jogosRodadaAtual[0].rodada + 1}`;\n  let novaRodada = [];\n  for (let i = 0; i < vencedores.length; i += 2) {\n    if (vencedores[i + 1]) {\n      novaRodada.push({\n        dupla1: vencedores[i],\n        dupla2: vencedores[i + 1],\n        placar: '',\n        submetido: false,\n        fase: novaFaseNome,\n        rodada: jogosRodadaAtual[0].rodada + 1\n      });\n    } else {\n      novaRodada.push({\n        dupla1: vencedores[i],\n        dupla2: ['BYE', ''],\n        // Caso seja um número ímpar\n        placar: '',\n        submetido: false,\n        fase: novaFaseNome,\n        rodada: jogosRodadaAtual[0].rodada + 1\n      });\n    }\n  }\n  return novaRodada;\n};","map":{"version":3,"names":["classificarDuplas","grupos","classificados","forEach","grupo","duplasClassificadas","classificarDuplasPorDesempate","duplas","jogos","push","console","log","criarJogosParaGrupo","grupoId","i","length","j","dupla1","dupla2","placar","submetido","dividirGrupos","numGrupos","Math","ceil","Array","fill","map","_","id","slice","resultados","reduce","acc","dupla","join","pontos","saldoGames","jogo","games1","games2","split","Number","chave1","chave2","Object","values","sort","a","b","r","iniciarFaseEliminatoria","jogosEliminatoria","rodada","classificadosOrdenados","rodadasTotal","log2","proximoMultiplo","pow","index","fase","faseNome","avancarRodadaEliminatoria","jogosRodadaAtual","vencedores","score1","score2","isNaN","novaFaseNome","novaRodada"],"sources":["C:/Users/Netto/Desktop/Meus projetos/torneioBT/gerenciador-beach-tennis/src/utils/torneioUtils.js"],"sourcesContent":["// src/utils/torneioUtils.js\r\nexport const classificarDuplas = (grupos) => {\r\n  let classificados = [];\r\n\r\n  grupos.forEach(grupo => {\r\n    // Ordena duplas do grupo com base nos critérios de desempate\r\n    const duplasClassificadas = classificarDuplasPorDesempate(grupo.duplas, grupo.jogos);\r\n\r\n    // Adiciona os 2 melhores de cada grupo à lista de classificados\r\n    classificados.push(duplasClassificadas[0], duplasClassificadas[1]);\r\n  });\r\n\r\n  console.log(\"Duplas classificadas para a fase eliminatória:\", classificados);\r\n  return classificados;\r\n};\r\n\r\nexport const criarJogosParaGrupo = (duplas, grupoId) => {\r\n  const jogos = [];\r\n  for (let i = 0; i < duplas.length; i++) {\r\n    for (let j = i + 1; j < duplas.length; j++) {\r\n      jogos.push({\r\n        dupla1: duplas[i],\r\n        dupla2: duplas[j],\r\n        placar: '',\r\n        submetido: false,\r\n        grupoId\r\n      });\r\n    }\r\n  }\r\n  return jogos;\r\n};\r\n\r\nexport const dividirGrupos = (duplas) => {\r\n  let numGrupos = Math.ceil(duplas.length / 3); // 3 é o número mínimo de duplas por grupo\r\n  \r\n  if (duplas.length <= 5) numGrupos = 1; // Grupo único para até 5 duplas\r\n  else if (duplas.length <= 8) numGrupos = 2;\r\n  else if (duplas.length <= 11) numGrupos = 3;\r\n  else if (duplas.length <= 14) numGrupos = 4;\r\n  else if (duplas.length <= 17) numGrupos = 5;\r\n  else if (duplas.length <= 20) numGrupos = 6;\r\n\r\n  const grupos = Array(numGrupos).fill().map((_, i) => ({\r\n    id: i,\r\n    duplas: duplas.slice(i * Math.ceil(duplas.length / numGrupos), (i + 1) * Math.ceil(duplas.length / numGrupos))\r\n  }));\r\n\r\n  return grupos;\r\n};\r\n\r\nexport const classificarDuplasPorDesempate = (duplas, jogos) => {\r\n  const resultados = duplas.reduce((acc, dupla) => {\r\n    acc[dupla.join('')] = { dupla, pontos: 0, saldoGames: 0 };\r\n    return acc;\r\n  }, {});\r\n\r\n  jogos.forEach(jogo => {\r\n    if (jogo.placar) {\r\n      const [games1, games2] = jogo.placar.split('-').map(Number);\r\n      const chave1 = jogo.dupla1.join('');\r\n      const chave2 = jogo.dupla2.join('');\r\n\r\n      if (games1 > games2) {\r\n        resultados[chave1].pontos += 5;\r\n        resultados[chave2].pontos += 2; // Pode ajustar essa pontuação se necessário\r\n      } else {\r\n        resultados[chave2].pontos += 5;\r\n        resultados[chave1].pontos += 2;\r\n      }\r\n\r\n      // Adiciona saldo de games para critério de desempate\r\n      resultados[chave1].saldoGames += games1 - games2;\r\n      resultados[chave2].saldoGames += games2 - games1;\r\n    }\r\n  });\r\n\r\n  // Ordena primeiro por pontos, depois por saldo de games\r\n  return Object.values(resultados)\r\n    .sort((a, b) => b.pontos - a.pontos || b.saldoGames - a.saldoGames)\r\n    .map(r => r.dupla);\r\n};\r\n\r\nexport const iniciarFaseEliminatoria = (classificados) => {\r\n  let jogosEliminatoria = [];\r\n  let rodada = 1;\r\n\r\n  // Classificação das duplas\r\n  const classificadosOrdenados = classificados;\r\n\r\n  // Determina o número de rodadas necessárias\r\n  let rodadasTotal = Math.ceil(Math.log2(classificadosOrdenados.length));\r\n\r\n  // Se for um número de duplas que não é potência de 2, ajustamos para incluir BYEs\r\n  let proximoMultiplo = Math.pow(2, rodadasTotal);\r\n  \r\n  // Adiciona BYEs se necessário\r\n  while (classificadosOrdenados.length < proximoMultiplo) {\r\n    classificadosOrdenados.push(['BYE', '']);\r\n  }\r\n\r\n  // Aqui, para casos específicos como 9 duplas, ajustamos manualmente:\r\n  if (classificados.length === 9) {\r\n    // Para 9 duplas, 2 avançam BYE, 4 para quartas\r\n    jogosEliminatoria = [\r\n      ...classificadosOrdenados.slice(2, 6).reduce((acc, dupla, index) => {\r\n        if (index % 2 === 0) {\r\n          acc.push({\r\n            dupla1: dupla,\r\n            dupla2: classificadosOrdenados[2 + index + 1],\r\n            placar: '',\r\n            submetido: false,\r\n            fase: 'Quartas de Final',\r\n            rodada: 1\r\n          });\r\n        }\r\n        return acc;\r\n      }, []),\r\n      {\r\n        dupla1: classificadosOrdenados[0],\r\n        dupla2: ['BYE', ''],\r\n        placar: '',\r\n        submetido: false,\r\n        fase: 'Semifinal',\r\n        rodada: 2\r\n      },\r\n      {\r\n        dupla1: classificadosOrdenados[1],\r\n        dupla2: ['BYE', ''],\r\n        placar: '',\r\n        submetido: false,\r\n        fase: 'Semifinal',\r\n        rodada: 2\r\n      }\r\n    ];\r\n    return jogosEliminatoria;\r\n  }\r\n\r\n  // Lógica para outros casos (número de duplas != 9)\r\n  for (let i = 0; i < classificadosOrdenados.length; i += 2) {\r\n    let faseNome = rodadasTotal === 1 ? 'Final' : \r\n                   rodadasTotal === 2 ? 'Semifinal' : \r\n                   rodadasTotal === 3 ? 'Quartas de Final' : \r\n                   `Rodada ${rodada}`;\r\n    \r\n    jogosEliminatoria.push({\r\n      dupla1: classificadosOrdenados[i],\r\n      dupla2: classificadosOrdenados[i + 1] || ['BYE', ''],\r\n      placar: '',\r\n      submetido: false,\r\n      fase: faseNome,\r\n      rodada: rodada\r\n    });\r\n  }\r\n\r\n  return jogosEliminatoria;\r\n};\r\n\r\nexport const avancarRodadaEliminatoria = (jogosRodadaAtual) => {\r\n  let vencedores = jogosRodadaAtual.map(jogo => {\r\n    const [score1, score2] = jogo.placar.split('-').map(Number);\r\n    if (jogo.dupla2[0] === 'BYE') return jogo.dupla1;\r\n    if (isNaN(score1) || isNaN(score2)) return jogo.dupla1; // Placeholder caso não tenha placar\r\n    return score1 > score2 ? jogo.dupla1 : jogo.dupla2;\r\n  });\r\n\r\n  let rodadasTotal = Math.ceil(Math.log2(vencedores.length));\r\n  let novaFaseNome = ['Final', 'Semifinal', 'Quartas de Final'][rodadasTotal - 1] || `Rodada ${jogosRodadaAtual[0].rodada + 1}`;\r\n\r\n  let novaRodada = [];\r\n  for (let i = 0; i < vencedores.length; i += 2) {\r\n    if (vencedores[i + 1]) {\r\n      novaRodada.push({\r\n        dupla1: vencedores[i],\r\n        dupla2: vencedores[i + 1],\r\n        placar: '',\r\n        submetido: false,\r\n        fase: novaFaseNome,\r\n        rodada: jogosRodadaAtual[0].rodada + 1\r\n      });\r\n    } else {\r\n      novaRodada.push({\r\n        dupla1: vencedores[i],\r\n        dupla2: ['BYE', ''], // Caso seja um número ímpar\r\n        placar: '',\r\n        submetido: false,\r\n        fase: novaFaseNome,\r\n        rodada: jogosRodadaAtual[0].rodada + 1\r\n      });\r\n    }\r\n  }\r\n  return novaRodada;\r\n};\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}