{"ast":null,"code":"// src/utils/torneioUtils.js\n\n// Classifica as duplas com base nos critérios de desempate\nexport const classificarDuplasPorDesempate = (duplas, jogos) => {\n  const resultados = duplas.reduce((acc, dupla) => {\n    if (!dupla || !Array.isArray(dupla) || dupla.length !== 2) {\n      console.error('Dupla inválida:', dupla);\n      return acc;\n    }\n    acc[dupla.join('')] = {\n      dupla,\n      pontos: 0,\n      saldoGames: 0\n    };\n    return acc;\n  }, {});\n  jogos.forEach(jogo => {\n    if (jogo.placar && jogo.dupla1 && jogo.dupla2 && Array.isArray(jogo.dupla1) && Array.isArray(jogo.dupla2)) {\n      const [games1, games2] = jogo.placar.split('-').map(Number);\n      const chave1 = jogo.dupla1.join('');\n      const chave2 = jogo.dupla2.join('');\n      if (resultados[chave1] && resultados[chave2]) {\n        if (games1 > games2) {\n          resultados[chave1].pontos += 5;\n          resultados[chave2].pontos += 2;\n        } else {\n          resultados[chave2].pontos += 5;\n          resultados[chave1].pontos += 2;\n        }\n        resultados[chave1].saldoGames += games1 - games2;\n        resultados[chave2].saldoGames += games2 - games1;\n      } else {\n        console.error('Dupla não encontrada em resultados:', {\n          chave1,\n          chave2,\n          jogo\n        });\n      }\n    } else {\n      console.error('Jogo inválido ignorado:', jogo);\n    }\n  });\n  return Object.values(resultados).sort((a, b) => b.pontos - a.pontos || b.saldoGames - a.saldoGames).map(r => r.dupla);\n};\n\n// Cria jogos para um grupo específico\nexport const criarJogosParaGrupo = (duplas, grupoId) => {\n  const jogos = [];\n  for (let i = 0; i < duplas.length; i++) {\n    for (let j = i + 1; j < duplas.length; j++) {\n      jogos.push({\n        dupla1: duplas[i],\n        dupla2: duplas[j],\n        placar: '',\n        submetido: false,\n        grupoId\n      });\n    }\n  }\n  return jogos;\n};\n\n// Divide as duplas em grupos\nexport const dividirGrupos = duplas => {\n  let numGrupos;\n  if (duplas.length === 10) {\n    numGrupos = 2;\n  } else if (duplas.length <= 5) {\n    numGrupos = 1;\n  } else if (duplas.length <= 8) {\n    numGrupos = 2;\n  } else if (duplas.length <= 11) {\n    numGrupos = 3;\n  } else if (duplas.length <= 14) {\n    numGrupos = 4;\n  } else if (duplas.length <= 17) {\n    numGrupos = 5;\n  } else if (duplas.length <= 20) {\n    numGrupos = 6;\n  } else {\n    numGrupos = Math.ceil(duplas.length / 3);\n  }\n  const grupos = Array(numGrupos).fill().map((_, i) => ({\n    id: i,\n    duplas: duplas.slice(i * Math.ceil(duplas.length / numGrupos), (i + 1) * Math.ceil(duplas.length / numGrupos))\n  }));\n  return grupos.filter(grupo => grupo.duplas.length > 0);\n};\n\n// Classifica as duplas para a fase eliminatória\nexport const classificarDuplas = grupos => {\n  let classificados = [];\n  grupos.forEach(grupo => {\n    const duplasClassificadas = classificarDuplasPorDesempate(grupo.duplas, grupo.jogos);\n    classificados.push(duplasClassificadas[0], duplasClassificadas[1]);\n  });\n  console.log('Duplas classificadas para a fase eliminatória:', classificados);\n  return classificados;\n};\n\n// Inicia a fase eliminatória com a primeira rodada\nexport const iniciarFaseEliminatoria = classificados => {\n  let totalDuplas = classificados.length;\n  let rodadas = Math.ceil(Math.log2(totalDuplas));\n  let proximoMultiplo = Math.pow(2, rodadas);\n  let byes = proximoMultiplo - totalDuplas;\n  let classificadosAjustados = [...classificados];\n  for (let i = 0; i < byes; i++) {\n    classificadosAjustados.push(['BYE', '']);\n  }\n  let faseNome;\n  if (rodadas === 1) {\n    faseNome = 'Final';\n  } else if (rodadas === 2) {\n    faseNome = 'Semifinal';\n  } else if (rodadas === 3) {\n    faseNome = 'Quartas de Final';\n  } else {\n    faseNome = `Rodada 1`;\n  }\n  let jogosRodada = [];\n  for (let i = 0; i < classificadosAjustados.length; i += 2) {\n    jogosRodada.push({\n      dupla1: classificadosAjustados[i],\n      dupla2: classificadosAjustados[i + 1],\n      placar: '',\n      submetido: false,\n      fase: faseNome,\n      rodada: 1\n    });\n  }\n  return jogosRodada;\n};\n\n// Avança para a próxima rodada na fase eliminatória\nexport const avancarRodadaEliminatoria = jogosRodadaAtual => {\n  let vencedores = jogosRodadaAtual.map(jogo => {\n    const [score1, score2] = jogo.placar.split('-').map(Number);\n    if (jogo.dupla2[0] === 'BYE') return jogo.dupla1;\n    return score1 > score2 ? jogo.dupla1 : jogo.dupla2;\n  });\n  let rodadasTotal = Math.ceil(Math.log2(vencedores.length));\n  let novaFaseNome = ['Final', 'Semifinal', 'Quartas de Final'][rodadasTotal - 1] || `Rodada ${jogosRodadaAtual[0].rodada + 1}`;\n  let novaRodada = [];\n  for (let i = 0; i < vencedores.length; i += 2) {\n    if (vencedores[i + 1]) {\n      novaRodada.push({\n        dupla1: vencedores[i],\n        dupla2: vencedores[i + 1],\n        placar: '',\n        submetido: false,\n        fase: novaFaseNome,\n        rodada: jogosRodadaAtual[0].rodada + 1\n      });\n    } else {\n      novaRodada.push({\n        dupla1: vencedores[i],\n        dupla2: ['BYE', ''],\n        placar: '',\n        submetido: false,\n        fase: novaFaseNome,\n        rodada: jogosRodadaAtual[0].rodada + 1\n      });\n    }\n  }\n  return novaRodada;\n};\n\n// Gera um torneio como rascunho para salvamento antecipado\nexport const generateTournament = (nome, duplas, dataInicio, horaInicio) => {\n  if (duplas.length < 3) {\n    throw new Error('É necessário pelo menos 3 duplas para criar um torneio.');\n  }\n  if (!nome || !dataInicio || !horaInicio) {\n    throw new Error('Nome, data e hora de início são obrigatórios.');\n  }\n  const tournaments = loadTournaments();\n  if (tournaments[nome]) {\n    throw new Error('Já existe um torneio com esse nome. Escolha outro nome.');\n  }\n  const duplasSorteadas = [...duplas].sort(() => Math.random() - 0.5);\n  const gruposCriados = dividirGrupos(duplasSorteadas);\n  const gruposComJogos = gruposCriados.map(grupo => ({\n    ...grupo,\n    jogos: criarJogosParaGrupo(grupo.duplas, grupo.id)\n  }));\n  const [ano, mes, dia] = dataInicio.split('-').map(Number);\n  const [hora, minuto] = horaInicio.split(':').map(Number);\n  const dataTorneio = new Date(ano, mes - 1, dia, hora, minuto).toISOString();\n  const tournament = {\n    nome,\n    dataCriacao: new Date().toISOString(),\n    dataTorneio,\n    dataInicio,\n    horaInicio,\n    duplas: duplasSorteadas,\n    grupos: gruposComJogos,\n    jogosEliminatoria: [],\n    finalConfigurada: false,\n    terceiroLugarConfigurado: false,\n    ranking: [],\n    duplasBye: [],\n    historicoDuplas: duplasSorteadas.reduce((acc, dupla) => {\n      acc[dupla.join('')] = {\n        dupla,\n        pontos: 0,\n        jogos: 0,\n        jogosVencidos: 0,\n        gamesVencidos: 0,\n        gamesPerdidos: 0\n      };\n      return acc;\n    }, {}),\n    status: 'rascunho',\n    faseAtual: 'duplas'\n  };\n  saveTournament(tournament);\n  return tournament;\n};\n\n// Salva um torneio no localStorage\nexport const saveTournament = tournamentData => {\n  const tournaments = JSON.parse(localStorage.getItem('tournaments') || '{}');\n  tournaments[tournamentData.nome] = tournamentData; // Sobrescreve se já existe\n  localStorage.setItem('tournaments', JSON.stringify(tournaments));\n};\n\n// Carrega todos os torneios salvos\nexport const loadTournaments = () => {\n  return JSON.parse(localStorage.getItem('tournaments') || '{}');\n};\n\n// Remove um torneio específico\nexport const deleteTournament = nome => {\n  const tournaments = JSON.parse(localStorage.getItem('tournaments') || '{}');\n  delete tournaments[nome];\n  localStorage.setItem('tournaments', JSON.stringify(tournaments));\n};","map":{"version":3,"names":["classificarDuplasPorDesempate","duplas","jogos","resultados","reduce","acc","dupla","Array","isArray","length","console","error","join","pontos","saldoGames","forEach","jogo","placar","dupla1","dupla2","games1","games2","split","map","Number","chave1","chave2","Object","values","sort","a","b","r","criarJogosParaGrupo","grupoId","i","j","push","submetido","dividirGrupos","numGrupos","Math","ceil","grupos","fill","_","id","slice","filter","grupo","classificarDuplas","classificados","duplasClassificadas","log","iniciarFaseEliminatoria","totalDuplas","rodadas","log2","proximoMultiplo","pow","byes","classificadosAjustados","faseNome","jogosRodada","fase","rodada","avancarRodadaEliminatoria","jogosRodadaAtual","vencedores","score1","score2","rodadasTotal","novaFaseNome","novaRodada","generateTournament","nome","dataInicio","horaInicio","Error","tournaments","loadTournaments","duplasSorteadas","random","gruposCriados","gruposComJogos","ano","mes","dia","hora","minuto","dataTorneio","Date","toISOString","tournament","dataCriacao","jogosEliminatoria","finalConfigurada","terceiroLugarConfigurado","ranking","duplasBye","historicoDuplas","jogosVencidos","gamesVencidos","gamesPerdidos","status","faseAtual","saveTournament","tournamentData","JSON","parse","localStorage","getItem","setItem","stringify","deleteTournament"],"sources":["C:/Users/Netto/Desktop/Meus projetos/torneioBT/gerenciador-beach-tennis/src/utils/torneioUtils.js"],"sourcesContent":["// src/utils/torneioUtils.js\r\n\r\n// Classifica as duplas com base nos critérios de desempate\r\nexport const classificarDuplasPorDesempate = (duplas, jogos) => {\r\n  const resultados = duplas.reduce((acc, dupla) => {\r\n    if (!dupla || !Array.isArray(dupla) || dupla.length !== 2) {\r\n      console.error('Dupla inválida:', dupla);\r\n      return acc;\r\n    }\r\n    acc[dupla.join('')] = { dupla, pontos: 0, saldoGames: 0 };\r\n    return acc;\r\n  }, {});\r\n\r\n  jogos.forEach((jogo) => {\r\n    if (\r\n      jogo.placar &&\r\n      jogo.dupla1 &&\r\n      jogo.dupla2 &&\r\n      Array.isArray(jogo.dupla1) &&\r\n      Array.isArray(jogo.dupla2)\r\n    ) {\r\n      const [games1, games2] = jogo.placar.split('-').map(Number);\r\n      const chave1 = jogo.dupla1.join('');\r\n      const chave2 = jogo.dupla2.join('');\r\n\r\n      if (resultados[chave1] && resultados[chave2]) {\r\n        if (games1 > games2) {\r\n          resultados[chave1].pontos += 5;\r\n          resultados[chave2].pontos += 2;\r\n        } else {\r\n          resultados[chave2].pontos += 5;\r\n          resultados[chave1].pontos += 2;\r\n        }\r\n        resultados[chave1].saldoGames += games1 - games2;\r\n        resultados[chave2].saldoGames += games2 - games1;\r\n      } else {\r\n        console.error('Dupla não encontrada em resultados:', { chave1, chave2, jogo });\r\n      }\r\n    } else {\r\n      console.error('Jogo inválido ignorado:', jogo);\r\n    }\r\n  });\r\n\r\n  return Object.values(resultados)\r\n    .sort((a, b) => b.pontos - a.pontos || b.saldoGames - a.saldoGames)\r\n    .map((r) => r.dupla);\r\n};\r\n\r\n// Cria jogos para um grupo específico\r\nexport const criarJogosParaGrupo = (duplas, grupoId) => {\r\n  const jogos = [];\r\n  for (let i = 0; i < duplas.length; i++) {\r\n    for (let j = i + 1; j < duplas.length; j++) {\r\n      jogos.push({\r\n        dupla1: duplas[i],\r\n        dupla2: duplas[j],\r\n        placar: '',\r\n        submetido: false,\r\n        grupoId,\r\n      });\r\n    }\r\n  }\r\n  return jogos;\r\n};\r\n\r\n// Divide as duplas em grupos\r\nexport const dividirGrupos = (duplas) => {\r\n  let numGrupos;\r\n  if (duplas.length === 10) {\r\n    numGrupos = 2;\r\n  } else if (duplas.length <= 5) {\r\n    numGrupos = 1;\r\n  } else if (duplas.length <= 8) {\r\n    numGrupos = 2;\r\n  } else if (duplas.length <= 11) {\r\n    numGrupos = 3;\r\n  } else if (duplas.length <= 14) {\r\n    numGrupos = 4;\r\n  } else if (duplas.length <= 17) {\r\n    numGrupos = 5;\r\n  } else if (duplas.length <= 20) {\r\n    numGrupos = 6;\r\n  } else {\r\n    numGrupos = Math.ceil(duplas.length / 3);\r\n  }\r\n\r\n  const grupos = Array(numGrupos)\r\n    .fill()\r\n    .map((_, i) => ({\r\n      id: i,\r\n      duplas: duplas.slice(\r\n        i * Math.ceil(duplas.length / numGrupos),\r\n        (i + 1) * Math.ceil(duplas.length / numGrupos)\r\n      ),\r\n    }));\r\n\r\n  return grupos.filter((grupo) => grupo.duplas.length > 0);\r\n};\r\n\r\n// Classifica as duplas para a fase eliminatória\r\nexport const classificarDuplas = (grupos) => {\r\n  let classificados = [];\r\n\r\n  grupos.forEach((grupo) => {\r\n    const duplasClassificadas = classificarDuplasPorDesempate(grupo.duplas, grupo.jogos);\r\n    classificados.push(duplasClassificadas[0], duplasClassificadas[1]);\r\n  });\r\n\r\n  console.log('Duplas classificadas para a fase eliminatória:', classificados);\r\n  return classificados;\r\n};\r\n\r\n// Inicia a fase eliminatória com a primeira rodada\r\nexport const iniciarFaseEliminatoria = (classificados) => {\r\n  let totalDuplas = classificados.length;\r\n  let rodadas = Math.ceil(Math.log2(totalDuplas));\r\n  let proximoMultiplo = Math.pow(2, rodadas);\r\n  let byes = proximoMultiplo - totalDuplas;\r\n  let classificadosAjustados = [...classificados];\r\n  for (let i = 0; i < byes; i++) {\r\n    classificadosAjustados.push(['BYE', '']);\r\n  }\r\n\r\n  let faseNome;\r\n  if (rodadas === 1) {\r\n    faseNome = 'Final';\r\n  } else if (rodadas === 2) {\r\n    faseNome = 'Semifinal';\r\n  } else if (rodadas === 3) {\r\n    faseNome = 'Quartas de Final';\r\n  } else {\r\n    faseNome = `Rodada 1`;\r\n  }\r\n\r\n  let jogosRodada = [];\r\n  for (let i = 0; i < classificadosAjustados.length; i += 2) {\r\n    jogosRodada.push({\r\n      dupla1: classificadosAjustados[i],\r\n      dupla2: classificadosAjustados[i + 1],\r\n      placar: '',\r\n      submetido: false,\r\n      fase: faseNome,\r\n      rodada: 1,\r\n    });\r\n  }\r\n  return jogosRodada;\r\n};\r\n\r\n// Avança para a próxima rodada na fase eliminatória\r\nexport const avancarRodadaEliminatoria = (jogosRodadaAtual) => {\r\n  let vencedores = jogosRodadaAtual.map((jogo) => {\r\n    const [score1, score2] = jogo.placar.split('-').map(Number);\r\n    if (jogo.dupla2[0] === 'BYE') return jogo.dupla1;\r\n    return score1 > score2 ? jogo.dupla1 : jogo.dupla2;\r\n  });\r\n\r\n  let rodadasTotal = Math.ceil(Math.log2(vencedores.length));\r\n  let novaFaseNome =\r\n    ['Final', 'Semifinal', 'Quartas de Final'][rodadasTotal - 1] ||\r\n    `Rodada ${jogosRodadaAtual[0].rodada + 1}`;\r\n\r\n  let novaRodada = [];\r\n  for (let i = 0; i < vencedores.length; i += 2) {\r\n    if (vencedores[i + 1]) {\r\n      novaRodada.push({\r\n        dupla1: vencedores[i],\r\n        dupla2: vencedores[i + 1],\r\n        placar: '',\r\n        submetido: false,\r\n        fase: novaFaseNome,\r\n        rodada: jogosRodadaAtual[0].rodada + 1,\r\n      });\r\n    } else {\r\n      novaRodada.push({\r\n        dupla1: vencedores[i],\r\n        dupla2: ['BYE', ''],\r\n        placar: '',\r\n        submetido: false,\r\n        fase: novaFaseNome,\r\n        rodada: jogosRodadaAtual[0].rodada + 1,\r\n      });\r\n    }\r\n  }\r\n  return novaRodada;\r\n};\r\n\r\n// Gera um torneio como rascunho para salvamento antecipado\r\nexport const generateTournament = (nome, duplas, dataInicio, horaInicio) => {\r\n  if (duplas.length < 3) {\r\n    throw new Error('É necessário pelo menos 3 duplas para criar um torneio.');\r\n  }\r\n  if (!nome || !dataInicio || !horaInicio) {\r\n    throw new Error('Nome, data e hora de início são obrigatórios.');\r\n  }\r\n\r\n  const tournaments = loadTournaments();\r\n  if (tournaments[nome]) {\r\n    throw new Error('Já existe um torneio com esse nome. Escolha outro nome.');\r\n  }\r\n\r\n  const duplasSorteadas = [...duplas].sort(() => Math.random() - 0.5);\r\n  const gruposCriados = dividirGrupos(duplasSorteadas);\r\n  const gruposComJogos = gruposCriados.map((grupo) => ({\r\n    ...grupo,\r\n    jogos: criarJogosParaGrupo(grupo.duplas, grupo.id),\r\n  }));\r\n\r\n  const [ano, mes, dia] = dataInicio.split('-').map(Number);\r\n  const [hora, minuto] = horaInicio.split(':').map(Number);\r\n  const dataTorneio = new Date(ano, mes - 1, dia, hora, minuto).toISOString();\r\n\r\n  const tournament = {\r\n    nome,\r\n    dataCriacao: new Date().toISOString(),\r\n    dataTorneio,\r\n    dataInicio,\r\n    horaInicio,\r\n    duplas: duplasSorteadas,\r\n    grupos: gruposComJogos,\r\n    jogosEliminatoria: [],\r\n    finalConfigurada: false,\r\n    terceiroLugarConfigurado: false,\r\n    ranking: [],\r\n    duplasBye: [],\r\n    historicoDuplas: duplasSorteadas.reduce((acc, dupla) => {\r\n      acc[dupla.join('')] = {\r\n        dupla,\r\n        pontos: 0,\r\n        jogos: 0,\r\n        jogosVencidos: 0,\r\n        gamesVencidos: 0,\r\n        gamesPerdidos: 0,\r\n      };\r\n      return acc;\r\n    }, {}),\r\n    status: 'rascunho',\r\n    faseAtual: 'duplas',\r\n  };\r\n\r\n  saveTournament(tournament);\r\n  return tournament;\r\n};\r\n\r\n// Salva um torneio no localStorage\r\nexport const saveTournament = (tournamentData) => {\r\n  const tournaments = JSON.parse(localStorage.getItem('tournaments') || '{}');\r\n  tournaments[tournamentData.nome] = tournamentData; // Sobrescreve se já existe\r\n  localStorage.setItem('tournaments', JSON.stringify(tournaments));\r\n};\r\n\r\n// Carrega todos os torneios salvos\r\nexport const loadTournaments = () => {\r\n  return JSON.parse(localStorage.getItem('tournaments') || '{}');\r\n};\r\n\r\n// Remove um torneio específico\r\nexport const deleteTournament = (nome) => {\r\n  const tournaments = JSON.parse(localStorage.getItem('tournaments') || '{}');\r\n  delete tournaments[nome];\r\n  localStorage.setItem('tournaments', JSON.stringify(tournaments));\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}