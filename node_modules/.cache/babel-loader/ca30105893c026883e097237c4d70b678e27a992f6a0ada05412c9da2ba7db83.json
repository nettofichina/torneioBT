{"ast":null,"code":"// Função para dividir as duplas em grupos conforme o regulamento do torneio\nexport const dividirGrupos = duplas => {\n  if (duplas.length < 3) {\n    throw new Error(\"É necessário pelo menos 3 duplas para formar grupos.\");\n  }\n  let numGrupos;\n  if (duplas.length <= 5) numGrupos = 1;else if (duplas.length <= 8) numGrupos = 2;else if (duplas.length <= 11) numGrupos = 3;else if (duplas.length <= 14) numGrupos = 4;else if (duplas.length <= 17) numGrupos = 5;else numGrupos = 6;\n  let grupos = [];\n  let duplasPorGrupo = Math.floor(duplas.length / numGrupos);\n  let resto = duplas.length % numGrupos;\n  for (let i = 0; i < numGrupos; i++) {\n    let grupoSize = duplasPorGrupo + (i < resto ? 1 : 0);\n    grupos.push({\n      id: i,\n      duplas: duplas.splice(0, grupoSize),\n      jogos: []\n    });\n  }\n\n  // Ajuste final para garantir que cada grupo tenha pelo menos 3 duplas se possível\n  if (numGrupos > 1) {\n    while (grupos.some(g => g.duplas.length < 3) && duplas.length > 0) {\n      let menorGrupo = grupos.reduce((menor, grupo) => grupo.duplas.length < menor.duplas.length ? grupo : menor);\n      menorGrupo.duplas.push(duplas.shift());\n    }\n  }\n\n  // Atualizar jogos para cada grupo\n  grupos.forEach(grupo => {\n    grupo.jogos = criarJogosParaGrupo(grupo.duplas, grupo.id);\n  });\n  return grupos;\n};\n\n// Função para criar jogos para um grupo específico\nexport const criarJogosParaGrupo = (grupo, grupoIndex) => {\n  let jogosGrupo = [];\n  for (let i = 0; i < grupo.length; i++) {\n    for (let j = i + 1; j < grupo.length; j++) {\n      jogosGrupo.push({\n        dupla1: grupo[i],\n        dupla2: grupo[j],\n        placar: '',\n        submetido: false,\n        grupoIndex,\n        jogoIndex: jogosGrupo.length\n      });\n    }\n  }\n  return jogosGrupo;\n};\n\n// Objeto para armazenar as estatísticas das duplas\nexport const duplasEstatisticas = {};\n\n// Função para atualizar as estatísticas após um jogo\nexport const atualizarEstatisticas = jogo => {\n  const [set1, set2] = jogo.placar.split('-').map(Number);\n  const vencedor = set1 > set2 ? jogo.dupla1 : jogo.dupla2;\n  const perdedor = vencedor === jogo.dupla1 ? jogo.dupla2 : jogo.dupla1;\n  function updateStats(dupla, pontos) {\n    const duplaKey = dupla.join(',');\n    if (!duplasEstatisticas[duplaKey]) {\n      duplasEstatisticas[duplaKey] = {\n        jogos: 0,\n        pontos: 0,\n        setsVencidos: 0,\n        setsPerdidos: 0\n      };\n    }\n    duplasEstatisticas[duplaKey].jogos++;\n    duplasEstatisticas[duplaKey].pontos += pontos;\n    if (dupla === vencedor) {\n      duplasEstatisticas[duplaKey].setsVencidos += set1;\n      duplasEstatisticas[duplaKey].setsPerdidos += set2;\n    } else {\n      duplasEstatisticas[duplaKey].setsVencidos += set2;\n      duplasEstatisticas[duplaKey].setsPerdidos += set1;\n    }\n  }\n  updateStats(vencedor, 3); // Supondo 3 pontos por vitória\n  updateStats(perdedor, 1); // Supondo 1 ponto por derrota\n};\n\n// Função para classificar duplas por desempate\nexport const classificarDuplasPorDesempate = (grupo, jogos) => {\n  return grupo.sort((a, b) => {\n    let statsA = duplasEstatisticas[a.join(',')] || {\n      pontos: 0,\n      setsVencidos: 0,\n      setsPerdidos: 0\n    };\n    let statsB = duplasEstatisticas[b.join(',')] || {\n      pontos: 0,\n      setsVencidos: 0,\n      setsPerdidos: 0\n    };\n    if (statsB.pontos !== statsA.pontos) return statsB.pontos - statsA.pontos;\n    let saldoA = statsA.setsVencidos - statsA.setsPerdidos;\n    let saldoB = statsB.setsVencidos - statsB.setsPerdidos;\n    if (saldoA !== saldoB) return saldoB - saldoA;\n\n    // Confronto direto\n    const jogoDireto = jogos.find(j => j.dupla1.join(',') === a.join(',') && j.dupla2.join(',') === b.join(',') || j.dupla1.join(',') === b.join(',') && j.dupla2.join(',') === a.join(','));\n    if (jogoDireto) {\n      const [set1, set2] = jogoDireto.placar.split('-').map(Number);\n      return jogoDireto.dupla1.join(',') === a.join(',') ? set1 - set2 : set2 - set1;\n    }\n\n    // Se ainda estiver empatado, você pode adicionar mais critérios ou usar um sorteio\n    return 0;\n  });\n};","map":{"version":3,"names":["dividirGrupos","duplas","length","Error","numGrupos","grupos","duplasPorGrupo","Math","floor","resto","i","grupoSize","push","id","splice","jogos","some","g","menorGrupo","reduce","menor","grupo","shift","forEach","criarJogosParaGrupo","grupoIndex","jogosGrupo","j","dupla1","dupla2","placar","submetido","jogoIndex","duplasEstatisticas","atualizarEstatisticas","jogo","set1","set2","split","map","Number","vencedor","perdedor","updateStats","dupla","pontos","duplaKey","join","setsVencidos","setsPerdidos","classificarDuplasPorDesempate","sort","a","b","statsA","statsB","saldoA","saldoB","jogoDireto","find"],"sources":["C:/Users/Netto/Desktop/Meus projetos/torneioBT/gerenciador-beach-tennis/src/utils/torneioUtils.js"],"sourcesContent":["// Função para dividir as duplas em grupos conforme o regulamento do torneio\r\nexport const dividirGrupos = (duplas) => {\r\n  if (duplas.length < 3) {\r\n    throw new Error(\"É necessário pelo menos 3 duplas para formar grupos.\");\r\n  }\r\n  \r\n  let numGrupos;\r\n  if (duplas.length <= 5) numGrupos = 1;\r\n  else if (duplas.length <= 8) numGrupos = 2;\r\n  else if (duplas.length <= 11) numGrupos = 3;\r\n  else if (duplas.length <= 14) numGrupos = 4;\r\n  else if (duplas.length <= 17) numGrupos = 5;\r\n  else numGrupos = 6;\r\n\r\n  let grupos = [];\r\n  let duplasPorGrupo = Math.floor(duplas.length / numGrupos);\r\n  let resto = duplas.length % numGrupos;\r\n\r\n  for (let i = 0; i < numGrupos; i++) {\r\n    let grupoSize = duplasPorGrupo + (i < resto ? 1 : 0);\r\n    grupos.push({\r\n      id: i,\r\n      duplas: duplas.splice(0, grupoSize),\r\n      jogos: []\r\n    });\r\n  }\r\n\r\n  // Ajuste final para garantir que cada grupo tenha pelo menos 3 duplas se possível\r\n  if (numGrupos > 1) {\r\n    while (grupos.some(g => g.duplas.length < 3) && duplas.length > 0) {\r\n      let menorGrupo = grupos.reduce((menor, grupo) => grupo.duplas.length < menor.duplas.length ? grupo : menor);\r\n      menorGrupo.duplas.push(duplas.shift());\r\n    }\r\n  }\r\n\r\n  // Atualizar jogos para cada grupo\r\n  grupos.forEach(grupo => {\r\n    grupo.jogos = criarJogosParaGrupo(grupo.duplas, grupo.id);\r\n  });\r\n\r\n  return grupos;\r\n};\r\n  \r\n  // Função para criar jogos para um grupo específico\r\n  export const criarJogosParaGrupo = (grupo, grupoIndex) => {\r\n    let jogosGrupo = [];\r\n    for (let i = 0; i < grupo.length; i++) {\r\n      for (let j = i + 1; j < grupo.length; j++) {\r\n        jogosGrupo.push({\r\n          dupla1: grupo[i],\r\n          dupla2: grupo[j],\r\n          placar: '',\r\n          submetido: false,\r\n          grupoIndex,\r\n          jogoIndex: jogosGrupo.length\r\n        });\r\n      }\r\n    }\r\n    return jogosGrupo;\r\n  };\r\n  \r\n  // Objeto para armazenar as estatísticas das duplas\r\n  export const duplasEstatisticas = {};\r\n  \r\n  // Função para atualizar as estatísticas após um jogo\r\n  export const atualizarEstatisticas = (jogo) => {\r\n    const [set1, set2] = jogo.placar.split('-').map(Number);\r\n    const vencedor = set1 > set2 ? jogo.dupla1 : jogo.dupla2;\r\n    const perdedor = vencedor === jogo.dupla1 ? jogo.dupla2 : jogo.dupla1;\r\n  \r\n    function updateStats(dupla, pontos) {\r\n      const duplaKey = dupla.join(',');\r\n      if (!duplasEstatisticas[duplaKey]) {\r\n        duplasEstatisticas[duplaKey] = { jogos: 0, pontos: 0, setsVencidos: 0, setsPerdidos: 0 };\r\n      }\r\n      duplasEstatisticas[duplaKey].jogos++;\r\n      duplasEstatisticas[duplaKey].pontos += pontos;\r\n      if (dupla === vencedor) {\r\n        duplasEstatisticas[duplaKey].setsVencidos += set1;\r\n        duplasEstatisticas[duplaKey].setsPerdidos += set2;\r\n      } else {\r\n        duplasEstatisticas[duplaKey].setsVencidos += set2;\r\n        duplasEstatisticas[duplaKey].setsPerdidos += set1;\r\n      }\r\n    }\r\n  \r\n    updateStats(vencedor, 3); // Supondo 3 pontos por vitória\r\n    updateStats(perdedor, 1); // Supondo 1 ponto por derrota\r\n  };\r\n  \r\n  // Função para classificar duplas por desempate\r\n  export const classificarDuplasPorDesempate = (grupo, jogos) => {\r\n    return grupo.sort((a, b) => {\r\n      let statsA = duplasEstatisticas[a.join(',')] || { pontos: 0, setsVencidos: 0, setsPerdidos: 0 };\r\n      let statsB = duplasEstatisticas[b.join(',')] || { pontos: 0, setsVencidos: 0, setsPerdidos: 0 };\r\n      \r\n      if (statsB.pontos !== statsA.pontos) return statsB.pontos - statsA.pontos;\r\n      let saldoA = statsA.setsVencidos - statsA.setsPerdidos;\r\n      let saldoB = statsB.setsVencidos - statsB.setsPerdidos;\r\n      if (saldoA !== saldoB) return saldoB - saldoA;\r\n  \r\n      // Confronto direto\r\n      const jogoDireto = jogos.find(j => \r\n        (j.dupla1.join(',') === a.join(',') && j.dupla2.join(',') === b.join(',')) ||\r\n        (j.dupla1.join(',') === b.join(',') && j.dupla2.join(',') === a.join(','))\r\n      );\r\n      if (jogoDireto) {\r\n        const [set1, set2] = jogoDireto.placar.split('-').map(Number);\r\n        return jogoDireto.dupla1.join(',') === a.join(',') ? set1 - set2 : set2 - set1;\r\n      }\r\n  \r\n      // Se ainda estiver empatado, você pode adicionar mais critérios ou usar um sorteio\r\n      return 0;\r\n    });\r\n  };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}